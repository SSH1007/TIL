# 03 데이터 구조(Data Structure)

--- 

> **데이터 구조 활용**

- 데이터 구조를 활용하기 위해서는 메서드(method)를 활용
  
  - 메서드는 클래스 내부에 정의한 함수, 사실상 함수에 포함되는 개념.
  
  - 쉽게 설명하자면 객체의 기능
  
  - 데이터구조.메서드() 형태로 활용

---

>  **문자열(String Type)**

- 문자들의 나열
  
  - 모든 문자는 str 타입(변경 불가능함/immutable)

- 문자열은 작은 따옴표(')나 큰 따옴표(")를 활용하여 표기
  
  - 문자열을 묶을 때 동일한 문장부호를 활용
  
  - PEP8에서는 소스코드 내에서 하나의 문장부호를 선택하여 유지하도록 함

- 문자열 조회/탐색 및 검증 메서드
  
  - s.find(x) : x의 첫 번째 위치를 반환. 없으면 **-1을 반환**
  
  - s.index(x) : x의 첫 번째 위치를 반환. 없으면, **오류 발생**
  
  - s. isalpha() : 알파벳 **문자** 여부
    
    - (\* 단순 알파벳이 아닌 유니코드 상 Letter)
  
  - s.isupper() : 대문자 여부
  
  - s.islower() : 소문자 여부
  
  - s.istitle() : 타이틀 형식 여부
    
    - (처음은 대문자고 나머진 소문자)

- 문자열 검증 메서드
  
  - isdecimal() : 십진법
  
  - isdigit() : 소수, ⑭ 같은 것도 판별
  
  - isnumeric() : ¾ 參,⑭,Ⅸ 같은 것도 판별

- 문자열 변경 메서드  
  (기존의 문자열을 변경하는게 아니라 새로이 변경된 문자열을 만들어서 반환하는 것)
  
  - s.replace(old, new[,count]) : 바꿀 대상 글자를 새로운 글자로 바꿔서 반환
  
  - s.strip([chars]) : 공백이나, 특정 문자를 제거
    
    - 양쪽. lstrip은 왼쪽, rstrip은 오른쪽 제거
    - ```
      print('abcdcba'.strip('abc'))
      ```
    - 위의 값은 d가 나온다. 
      - 'abc'를 통째로 판별하는게 아니라 하나하나씩 판별하는것
  
  - s.split(sep=None, maxsplit=-1) : 
    
    - 공백이나 특정 문자를 기준으로 분리
  
  - 'separator'.join([iterable]) : 
    
    - 구분자로 iterable을 합쳐서 문자열 반환
    
    - 문자열이 아닌 값이 iterable에 들어오면 TypeError 
  
  - s.capitalize() : 가장 첫번째 글자를 대문자로 변경
  
  - s.title() : 문자열 내 띄어쓰기 기준으로 각 단어 첫글자는 대문자로, 나머지는 소문자로 변환
  
  - s.upper() : 모두 대문자로 변경
  
  - s.lower() : 모두 소문자로 변경
  
  - s.swapcase() : 대소문자 서로 변경

--- 

---

> 리스트

- 여러 개의 값을 순서가 있는 구조로 저장하고 싶을 때 사용

- 대괄호 [] 혹은 list()를 통해 생성
  
  - 어떠한 자료형도 저장 가능, 리스트 안에 리스트도 넣을 수 있음
  
  - 생성된 이후 내용 변경 가능(mutable)

- 순서가 있는 시퀀스로 인덱스를 통해 접근 가능
  
  - list[i]

- **리스트 메서드**
  
  - L.append(x) : 리스트 마지막에 항목 x를 추가
    
    - lst = [1,2,3,4,5]
    
    - lst[2:2] = [10,11] >> [1,2,10,11,3,4,5]
    
    - lst[2:3] = [10,11] >> [1,2,10,11,4,5]
  
  - L.insert(i,x) : 리스트 인덱스 i에 항목 x를 삽입
    
    - i가 리스트 길이보다 큰 경우, 맨 마지막에 넣는다
  
  - L.remove(x) : 
    
    - 리스트 가장 왼쪽에 있는 항목(첫번째) x를 제거
    
    - 항목이 존재하지 않을 경우, ValueError
  
  - L.pop() : 리스트 가장 오른쪽에 있는 항목(마지막)을 반환 후 제거
  
  - L.pop(i) : 리스트의 인덱스 i에 있는 항목을 반환 후 제거
  
  - L.extend(m) : 
    
    - 순회형 m의 모든 항목들을 리스트 끝에 추가  
      (+=과 같은 기능)
    
    - 문자열을 넣으면 쪼개져서 들어감
      
      - s.extend('cup')  >> s = ['c','u','p']
  
  - L.index(x,start,end) : 
    
    - 리스트에 있는 항목 중 가장 왼쪽에 있는 항목 x의 인덱스를 반환
    
    - 없는 항목이면 ValueError 반환
  
  - L.reverse() : 리스트 원본을 거꾸로 뒤집는다.
  
  - :boom: L.sort() : 리스트를 정렬(매개 변수 사용 가능)
    
    - 원본 리스트를 정렬함. None 반환
  
  - :boom: sorted(L) : 리스트를 정렬(매개 변수 사용 가능)
    
    - 복사 리스트를 정렬하여 반환
  
  - L.count(x) : 리스트에서 항목 x가 몇 개 존재하는지 갯수를 반환
  
  - L.clear() : 리스트 내의 요소들을 전부 삭제함
  
  --- 
  
  ---
  
  > **튜플**

- 여러 개의 값을 순서가 있는 구조로 저장
  
  - 생성 후 , 담고 있는 값 변경이 불가(immutable)
  
  - ```
    a= ([1,2,3],2,3)
    a[0][1]=100
    print(a) >> ([100,2,3],2,3)
    a[0]=100
    print(a) >> TypeError
    ```
    
    - 값 자체를 변경하는 건 불가능하지만,  
      
       값이 참조하는 주소의 값은 변경이 가능하다.

- 항상 소괄호 형태로 사용

- 값에 영향을 미치지 않는 메서드만 지원
  
  - 그 외에는 리스트와 동일

--- 

--- 

> 연산자

- 멤버십 연산자 in
  
  - 'a'  in 'apple' : True 반환
  
  - 'a' not in 'apple' : False 반환

- 시퀀스형 연산자
  
  - 산술 연산자(+)
    
    - 시퀀스 간의 연결
      
      - 리스트 [1,2]+['a'] = [1,2,'a']
      
      - 튜플 (1,2) + ('a') = (1,2,'a')
      
      - range(2) + range(3) 은 에러남
      
      - 문자열 '12'+'b' = '12b'
  
  - 반복 연산자(\*)
    
    - 시퀀스를 반복
    
    - range()만 에러남

---

---

> **셋(Set)**

- set이란 중복되는 요소가 없이, 순서에 상관없는 데이터들의 묶음
  
  - 중복되는 원소가 있다면 하나만 저장
  
  - 순서가 없어 인덱스를 이용한 접근 불가능

- **빈 셋을 만들 때는 ex = set()**

- 셋 안에는 리스트를 넣을 수 없음
  
  - imutable만 넣을 수 있음 (tuple, string)

- 수학에서의 집합을 표현한 컨테이너
  
  - 집합 연산 가능(여집합 연산자는 없음)

- 담고 있는 요소를 삽입, 변경, 삭제 가능(mutable) 

- 셋 메서드
  
  - s.copy() : 셋의 얕은 복사본을 반환
  
  - s.add(x) : 항목 x가 셋 s에 없다면 추가
  
  - s.pop() : 
    
    - 셋 s에서 랜덤하게 항목을 반환하고, 해당 항목을 제거
    
    - set이 비어있을 경우, KeyError
  
  - s.remove(x) : 항목 x를 셋 s에서 삭제
    
    - 항목이 존재하지 않을 경우, KeyError
  
  - s.discard(x) : 
    
    - 항목 x가 셋 s에 있는 경우, 항목 x를 셋 s에서 삭제
    
    - 항목이 존재하지 않아도 에러 발생 X
  
  - s. update(t) : 셋 t에 있는 모든 항목 중 셋 s에 없는 항목을 추가
  
  - s.clear() : 모든 항목을 제거
  
  - s.isdisjoint() : 셋 s가 셋 t의 서로 같은 항목을 하나라도 같고 있지 않은 경우, True 반환(서로소)
  
  - s.issubset(t) : 셋 s가 셋 t의 하위 셋인 경우, True 반환
  
  - s.issuperset(t) : 셋 s가 셋 t의 상위 셋인 경우, True 반환

---

---

> 딕셔너리

- 키-값 쌍으로 이루어진 자료형(3.7부터 ordered)

- 키(Key) 
  
  - 변경 불가능한 데이터(imutable)만 활용 가능
  
  - string, integer, float, boolean, tuple, range

- 값(Value)
  
  - 어떠한 형태든 관계 없음

- 딕셔너리 메서드
  
  - d.clear() : 모든 항목을 제거
  
  - d.get(key [,default]) : 
    
    - key를 통해 value를 가져옴
      
      - 키가 딕셔너리에 없으면 None 반환 
    
    - KeyError가 발생하지 않으며, default 값을 설정할 수 있음
      
      - 설정 시 key가 없어도 default 값 반환
  
  - d.setdefault(key[, default]) :
    
    - key가 딕셔너리에 있으면 value 반환
    - key가 딕셔너리에 없으면, default 값을 갖는 key를 반환한 뒤 default를 반환.
      - default가 주어지지 않았다면 None 반환
      - get이 조회하고 가져오기만 한다면, 얘는 조회하고 없으면 만들기까지 함.
  
  - d.pop(key [, default]) :
    
    - key가 딕셔너리에 있으면 제거하고 해당 값을 반환
    
    - 그렇지 않으면 default를 반환
    
    - default 값이 없으면 KeyError
  
  - d.update(key='value') : 값을 제공하는 key, value로 덮어쓴다.
    
    - () 안은 매개변수이므로 'key'='value' 이런식으로 쓰지 않음
    - dic.update({'key':value, 'key':'value'})로도 들어가짐
  
  - d.copy() : 딕셔너리 d의 얕은 복사본을 반환
  
  - d.keys() : 딕셔너리 d의 모든 키를 담은 뷰를 반환
  
  - d.values() : 딕셔너리 d의 모든 값을 담은 뷰를 반환
  
  - d.items() : 딕셔너리 d의 모든 키:값의 쌍을 담은 뷰를 반환

---

---

> **얕은 복사와 깊은 복사**

###### 복사 방법

- 할당
  
  - 대입 연산자(=)
    
    - 해당 객체에 대한 객체 참조(**주소**)를 복사
    
    - 해당 주소의 일부 값을 변경하는 경우, 이를 참조하는 모든 변수에 영향
    
    - 둘이 같은 사물함을 쓰는 것
      
      - 사물함 안의 종이에 글을 쓰면,   
        그 종이을 읽은 두 명은 똑같은 내용을 말하게 된다.

- 얕은 복사
  
  - Slice 연산자 활용하여 같은 원소를 가진 리스트지만 연산된 결과를 복사(다른 주소)
  
  - a = [1,2,3]
  
  - b = a[:]
  
  - 이러면 **값**을 복사해서 a,b가 같은 값을 가지게 됨(id는 다름)
  
  - 똑같은 사물함을 하나 더 가져와서 각자 쓰는 것
  
  - 복사하는 리스트의 원소가 주소를 참조하는 경우
    
    - b[2][0] 같은 2차원 이상의 리스트는 정상 작동 못함

- 깊은 복사
  
  - import copy한 뒤, copy.deepcopy() 사용
    
    - a = [1,2,['a', 'b']]
    
    - b = copy.deepcopy(a)
  
  - 주소 복사가 아니라 값 복사
  
  - 2차원 리스트에서도 정상 작동

# 
