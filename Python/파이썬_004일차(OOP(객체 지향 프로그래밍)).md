# 04 OOP(객체 지향 프로그래밍)

---

> **객체**

- 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 **여러개의 독립된 단위**, 즉 **객체**들의 모임으로 파악하고자 하는 것    

- 각각의 객체는 메시지를 주고 받고, 데이터를 처리할 수 있다.

- 객체는 정보와 행동(기능/메서드)으로 이루어져 있다.

- 추상화된 구조

#### 장점

- 클래스 단위로 모듈화시켜 개발할 수 있어 많은 인원과의 협업에 적합

- 필요한 부분만 수정하기 용이, 유지보수 쉬움

#### 단점

- 설계 시 많은 노력과 시간이 필요함
  
  - 다양한 객체들의 상호 작용 구조를 만들기 위해 많은 시간과 노력 필요
  
  - 실행 속도가 상대적으로 느림
    
    - 절차 지향은 컴퓨터의 처리구조와 비슷해서 더 빠르다.

### 객체(CS)

- 컴퓨터 과학에서 객체 또는 오브젝트는 **클래스에서 정의한 것을 토대로 메모리(실제 저장공간)에 할당된 것**으로, 프로그램에 사용되는 데이터 또는 식별자에 의해 참조되는 공간을 의미하며, 변수, 자료 구조, 함수 또는 메서드가 될 수 있다.

#### 클래스로 만든 객체를 인스턴스라고도 함

- 객체와 인스턴스의 차이점?
  
  - 타입의 인스턴스, 클래스의 인스턴스
  
  - 종속되어 있는 개념임
  
  - 객체는 특정 타입의 인스턴스다.

#### 클래스와 객체

- 클래스  == 타입

- 파이썬은 모든 것이 객체, 속성과 행동이 존재한다.

- 타입(클래스)과 실제 사례(값)

### 객체의 특징

- 타입 : 어떤 연산자와 조작이 가능한가?

- 속성 : 어떤 상태(데이터)를 가지는가?

- 조작법 : 어떤 행위(함수)를 할 수 있는가?

---

> **기본 문법**

- 클래스 정의 
  
  - class MyClass:
  
  - 대문자 시작
  
  - 설계도 역할

- 인스턴스 생성 
  
  - my_instance = MyClass()
  
  - 설계도로 만든 하나하나의 실체, 예시

- 메서드 호출 
  
  - my_instance.my_method()

- 속성 
  
  - my_instance.my_attribute

---

> **객체 비교하기**

- == (A,B 두 값이 같나요?)
  
  - 동등한(equal)
  
  - 변수가 참조하는 객체들이 동등한(**내용이 같은**) 경우, True
  
  - 두 객체가 같아 보이지만 실제로 동일한 대상을 가리키고 있다고 확인해준 것은 아님

- is (A가 B 그 자체인가요?)
  
  - 동일한(identical)
  
  - 두 변수가 **동일한 객체**를 가리키는 경우 True
  
  - 값 같고, 주소도 같음

---

> **속성**

- 특정 데이터 타입 / 클래스의 객체들이 가지게 될 상태/ 데이터를 의미

- 클래스 변수/인스턴스 변수가 존재

---

> **인스턴스 변수**

- 인스턴스 변수란?
  
  - 인스턴스가 개인적으로 가지고 있는 속성
  
  - 각 인스턴스의 고유한 변수

- 생성자 메서드(\_\_init\_\_)에서 self.\<name\>으로 정의

- 인스턴스가 생성된 이후 \<instance\>.\<name\>으로 사용

- ```python
  class Person:
      def __init__(self,name):
          self.name=name
  
  john = Person('john')
  print(john.name)  # john
  ```

- 인스턴스의 첫번째 인자는 무조건 self지만 생략됨
  
  - 알아서 자기 자신을 변수로 받음

---

> **클래스 변수**

- 클래스 선언 내부에서 정의

- \<classname\>.\<name\>으로 접근 및 할당

- ```python
  class Circle():
      pi = 3.14 # 클래스 변수
  
      def __init__(self,r):
          self.r = r  # 인스턴스 변수
  
  c1 = Circle(5)
  c2 = Circle(10)
  print(Circle.pi)  # 3.14
  print(c1.pi)  # 3.14
  print(c2.pi)  # 3.14
  
  Circle.pi = 5
  print(Circle.pi)  # 5 
  print(c1.pi) # 5
  print(c2.pi) # 5 
  ```

- 클래스 변수는 공용, 인스턴스 변수는 개인용

- 클래스 변수를 변경할 때는 항상 **클래스.클래스 변수** 형식으로 변경한다.
  
  - 위의 Circle.pi = 5에 해당

- 인스턴스에 호출한 변수가 없으면 클래스 변수에서 주워온다.
  
  - LEGB 룰과 흡사한 구조
  
  - print(c1.pi)를 했는데 인스턴스 변수가 아닌 클래스 변수를 가져옴

---

---

> **메서드**

- 특정 데이터 타입/클래스의 객체에 공통적으로 적용 가능한 행위(함수)

- 인스턴스 메서드(Instance Methods)
  
  - 인스턴스(,변수) 처리(개별행동)
  
  - 클래스 변수, 인스턴스 변수 둘 다 사용 가능
  
  - 인스턴스 변수를 사용하거나, 인스턴스 변수에 값을 설정하는 메서드
  
  - 클래스 내부에 정의되는 메서드의 기본
  
  - 호출 시, 첫번째 인자로 인스턴스 자기자신(**self**)이 자동으로 전달됨
    
    - self : 인스턴스 자기 자신
  
  - <mark>**생성자**</mark> 메서드
    
    - 인스턴스 객체가 생성될 때 자동으로 호출되는 메서드
    
    - 인스턴스 변수들을 초기값을 설정
      
      - 인스턴스 생성
      
      - \_\_init\_\_ 메서드 자동 호출
        
        - Double underscore(\_\_)가 있는 메서드는 특수한 동작을 위해 만들어진 메서드로 던더 메서드, 매직 메서드, 스페셜 메서드로도 불림
        
        - 특정 상황에 자동으로 불리는 메서드

- 클래스 메서드(Class Methods)
  
  - 클래스(,변수) 처리
  
  - 인스턴스 변수 사용이 불가능
  
  - @classmethod 데코레이터를 사용해서 정의
    
    - 함수를 어떤 함수로 꾸며서 새로운 기능을 부여
    
    - @데코레이터(함수명) 형태로 함수 위에 작성
  
  - 호출시 첫번째 인자로 클래스(cls)를 받음

- 정적 메서드(Static Methods)
  
  - 나머지
  
  - 속성을 다루지 않고(데이터의 변화 없이), 단지 기능(행동)만을 하는 메서드
  
  - 객체 상태나 클래스 상태를 수정할 수 없음
  
  - @staticmethod 를 위에 두는 것으로 정의
  
  - 일반 함수처럼 동작하지만, 클래스의 이름 공간에 귀속됨

---

> **인스턴스와 클래스 간의 이름 공간(namespace)**

- 클래스를 정의하면, 클래스와 해당하는 이름 공간 생성

- 인스턴스를 만들면, 인스턴스 객체가 생성되고 이름 공간 생성

- 인스턴스에서 특정 속성에 접근하면, 인스턴스-클래스 순으로 탐색.

---

--- 

> **객체지향의 핵심 4가지** 

- 추상화
  
  - 복잡한 것은 숨기고, 필요한 것만 들어내기    

- 상속
  
  - 두 클래스 사이 부모 - 자식 관계를 정립하는 것
    
    - 부모의 기능을 자식이 써먹는 것이 가능
    
    - 상위 클래스에 정의된 속성, 행동, 관계 및 제약 조건을 모두 상속 받음
    
    - 코드 재사용성이 높아짐
  
  - 클래스는 상속이 가능함
    
    - 모든 파이썬 클래스는 object를 상속 받음
    
    - class ChildClass(ParentClass):
  
  - 상속 관련 함수와 메서드
    
    - isinstance(object,classinfo)
      
      - object가 classinfo의 instance거나 subclass인 경우, True
    
    - issubclass(class,classinfo)
      
      - class가 classinfo의 subclass면 True
      
      - classinfo가 튜플로 올 때가 있는데, 이 경우 한개만 맞아도 True
    
    - super()
      
      - 자식클래스에 부모클래스의 요소를 호출하고 싶은 경우
      
      - super().\_\_init\_\_(\*arg) 하는 것으로 부모의 _\_init\_\_을 가져오는 등으로 활용 가능
    
    - mro 메서드(Method Resolution Order)
      
      - 해당 인스턴스의 클래스가 어떤 부모 클래스를 가지는지 확인하는 메서드
      
      - 기존의 인스턴스 -> 클래스 순으로 이름 공간을 탐색하는 과정에서 상속 관계에 있으면 인스턴스 -> 자식 클래스 -> 부모 클래스로 확장
  
  - 메서드 오버라이딩을 통해 자식 클래스에서 재정의 가능
  
  - 상속관계에서의 이름 공간은 인스턴스, 자식 클래스, 부모 클래스 순으로 탐색
  
  - 다중 상속
    
    - 두 개 이상의 클래스를 상속 받는 경우
    
    - 상속 받은 모든 클래스의 요소를 활용 가능함
    
    - 중복된 속성이나 메서드가 있는 경우, 상속 순서에 의해 결정됨
      
      - class classA(class1,class2)일 경우 class1의 속성을 우선적으로 받는다.

- 다형성
  
  - 이름이 동일한 메서드가 클래스에 따라 다르게 행동할 수 있음을 의미
  
  - 서로 다른 클래스에 속해 있는 객체들이 동일한 메시지에 대해 다른 방식으로 응답할 수 있음
  
  - 메서드 오버라이딩
    
    - 상속 받은 메서드를 재정의
      
      - 클래스 상속 시, 부모 클래스에서 정의한 메서드를 자식 클래스에서 변경
      
      - 부모 클래스의 메서드 이름과 기본 기능은 그대로 사용하지만, 특정 기능을 바꾸고 싶을 때 사용
      
      - 상속 받은 클래스에서 같은 이름의 메서드로 덮어씀
      
      - 부모 클래스의 메서드를 실행시키고 싶은 경우, super().를 사용
  
  - 파이썬에선 오버 로딩은 없음

- 캡슐화
  
  - 객체의 일부 구현 내용에 대해 외부로부터의 직접적인 액세스를 차단(민감한 정보를 숨기는 것)
  
  - 파이썬에서 암묵적으로 존재하지만, 언어적으로는 존재하지 않음
  
  - 접근 제어자 종류
    
    - Public Access Modifier
      
      - Public Member
        
        - 언더바 없이 시작하는 메서드나 속성
        
        - 어디서나 호출이 가능, 하위 클래스 override 허용
        
        - 일반적으로 작성되는 메서드와 속성의 대다수를 차지
    
    - Protected  Access Modifier
      
      - Protected Member
        
        - 언더바 1개로 시작하는 메서드나 속성
        
        - 암묵적 규칙에 의해 부모 클래스 내부와 자식 클래스에서만 호출 가능
        
        - 하위 클래스 override 허용
    
    - Private Acces Modifier
      
      - Private Member
        
        - 언더바 2개로 시작하는 메서드나 속성
        
        - 본 클래스 내부에서만 사용이 가능
        
        - 하위 클래스 상속 및 호출 불가능(오류)
        
        - 외부 호출 불가능(오류)
        
        - \_Class\_\_Pribate Member 형태로 호출할 수는 있다.
  
  - getter 메서드와 setter 메서드
    
    - 변수에 접근할 수 있는 메서드를 별도로 생성
      
      - getter 메서드 : 변수의 값을 읽는 메서드
        
        - @property 데코레이터 사용
      
      - setter 메서드 : 변수의 값을 설정하는 성격의 메서드
        
        - @변수.setter를 데코레이터로 사용

---

---

> **에러와 예외 처리**

- 디버깅
  
  - 최초의 버그 : 1945년 코볼 발명자 그레이스 호퍼가 컴퓨터 회로에 나방이 들어가 합선을 일으켜 비정상적으로 동작한 것을 발견
  
  - 에러 메시지가 발생하는 경우
    
    - 해당 위치를 찾아 메시지를 해결
  
  - 로직 에러가 발생하는 경우
    
    - 예상과 다른 결과가 나온 경우
      
      - 정상적으로 동작하였던 코드 이후 작성된 코드를 생각해봄
      
      - 전체 코드 훑어보기
      
      - 휴식
      
      - 누군가에게 설명해보면서 찾기
  
  - print 함수 활용해서 상시 파악

- 에러와 예외
  
  - 문법 에러(Syntax Error)
    
    - Syntax Error가 발생하면 실행 중지됨
    
    - 파일 이름, 줄번호, ^문자(caret 기호)를 통해 문제가 발생한 위치 표시
      
      - Invalid Syntax : 문법 오류 
      
      - assign to literal : 잘못된 할당
      
      - EOL(End of Line) : 보통 괄호 안 닫음
      
      - EOF(End of File) : 동일
  
  - 예외(Exception)
    
    - 실행 도중 예상치 못한 상황을 맞이하면, 프로그램 실행을 멈춤
      
      - 문장이나 표현식이 올바르더라도 발생하는 에러
    
    - 실행 중에 감지되는 에러
    
    - NameError, TypeError 등 여러 타입이 있음
      
      - ZeroDivisionError : 10/0
      
      - NameError : print(name_error) : 정의되지 않은 이름(namespace 상에 이름이 없음)
      
      - TypeError : 
        
        - 1+'1', round('3.5') 같이 해당 타입에 불가능한 동작을 지시했을 때, 
        
        - 함수 argument 누락
      
      - ValueError: 타입은 올바르나 값이 적절하지 않거나 없는 경우. 
      
      - int('3.5'), range(3).index(6)
      
      - IndexError : 인덱스가 존재하지 않거나 범위를 벗어나는 경우
      
      - KeyError : 없는 키를 참조하는 경우
      
      - FileNotFoundError : 해당 파일을 못 찾았을 때
      
      - ModuleNotFoundError : 해당 모듈을 못 찾았을 때
      
      - ImportError : 모듈은 있으나 존재하지 않는 클래스/함수를 가져오려할 때
      
      - KeyboardInterrupt : 임의로 프로그램을 종료했을 때
      
      - IndentationError : 들여쓰기가 적절하지 않은 경우
    
    - 모든 내장 예외는 Exception Class를 상속받아 이뤄짐
    
    - 사용자 정의 예외를 만들어 관리할 수 있음
  
  - 파이썬 내장 예외 계층 구조

- 예외 처리
  
  - try문 / except절을 이용
  
  - try문
    
    - 오류가 발생할 가능성이 있는 코드를 실행
    
    - 예외가 발생되지 않으면, except 없이 실행 종료
    
    - 반드시 한 개 이상의 except 문이 필요
  
  - except문
    
    - 예외가 발생하면, except 절이 실행
    
    - 예외 상황을 처리하는 코드를 받아서 적절한 조치
    
    - as 키워드를 활용하여 원본 에러 메시지를 사용 가능
      
      - 예외를 다른 이름에 대입
    
    - 복수의 예외 처리 시, 순차적으로 수행되기 때문에 가장 작은 범주부터 예외 처리를 해야 한다.
  
  - else문
    
    - try 문에서 예외가 발생하지 않으면 실행
  
  - finally문
    
    - 예외 발생 여부와 관계없이 항상 실행함

- 예외 발생 시키기
  
  - raise
    
    - raise 예외 이름
    
    - raise Exception('메시지')
